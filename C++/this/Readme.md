## this指针与类中的枚举类型
### 1. `this`指针
this指针的作用：
* 一个对象的`this`指针并不是对象本身的一部分，不会影响`sizeof(对象)`的结果；
* `this`作用域是在类的内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使没有写上`this`指针，编译器在编译的时候也会自动加上`this`的，它作为非静态成员函数的隐含形参，对各成员的访问均通过`this`进行。

个人理解：**对于静态成员以及函数来说，它们的地址在类第一次被创建的时候就已经确定了，并且所分配的内存是共享的，其它成员函数可以直接通过虚表访问到这片内存。而对于非静态成员变量和函数，它们的地址只有在对象被初始化的时候才能知道，所以可以通过`this`来访问这些成员变量。`this`指针放在寄存器中。。。**

* `this`是一个`const`变量，在编译过程中，它会被编译器变成`A *const`。
* 对于类中的`const`函数，由于调用过程中会隐式传入一个`this`指针，为了保证该函数不会修改类的成员变量，因此传入`const`函数的`this`指针需要指向`const`，因此该`this`指针会被编译器解析为`const A *const`。

> `this`在成员函数的开始执行前构造，在成员的执行结束后清除。在C++中类和结构体只有一个区别：类的成员默认是`private`的，而结构体的成员默认是`public`的。`this`是类的指针，如果换成结构体，那么`this`就是结构体的指针了。

### 2. 类中的枚举类型
又是我们希望某些常量只在类中有效。由于`#define`定义的宏常量是全局的，不能达到目的。此外，还有`const`，但是常量的数据成员只有在某个对象的生命周期内是常量，但是对于整个类而言却是可变的，因为类可以创建多个对象，不同对象中的`const`数据成员的值可以不同。

不能在类声明中初始化`const`数据成员。以下语法是错误的，因为类的对象未被创建时，编译器不知道`SIZE`的值是什么。
```c++
class A 
{
  const int SIZE = 100;   // warning
  int array[SIZE];  // 错误，未知的 SIZE 
}; 
```

正确的做法应该是在类的构造函数的初始化列表中进行：
```c++
lass A{
public:
    const int SIZE;
    A(int size);  // 构造函数
};

A::A(int size) : SIZE(size){  // 构造函数的实现

}

int main(int argc, char *argv[]){
    A a(100);
    A b(200);
    cout << a.SIZE << endl;
    cout << b.SIZE << endl;
    return 0;
}
```

对于前面提到的如何才能建立一个在整个类中都恒定的常量？
可以通过类中的枚举常量来实现。例如：
```c++
class Person{
public:
    typedef enum{
        BOY,
        GIRL
    }Sex;
};

cout << Person::BOY << endl;
cout << Person::GIRL << endl;
Person boy;
cout << boy.BOY << endl;
cout << boy.GIRL << endl;
```

枚举常量不会占用对象的存储空间，它们在编译时被全部求值。
枚举常量的缺点是：它的隐含数据类型是整型，其最大值有限，且不能表示浮点数。

使用`sizeof`获取到对象的存储空间最小值为1？



