### 1. 基础知识
为了实现虚函数，C++中使用一种成为虚拟表的特殊形式的动态绑定。该虚拟表是用于解决在动态绑定方式的函数调用函数的查找表。虚拟表有时会使用其它名称，例如`vtable`，“虚函数表”，“虚方法表”或“调度表”。

#### 1.1 虚函数表
C++中虚函数的实现都是通过虚函数表`vtable`来实现的。在这个表中，主要是存放一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，这个表中的内容真实的指明了函数所在地址。在有虚函数的类的对象中，这个表占用了该对象的空间，有一个指向这张表的指针`vptr`，所以当我们用弗雷的指针来操作子类对象的时候，这样虚函数表就显得尤为重要，它就像一个地图一样，指明了实际应该调用的函数。

C++的编译器应该是保证虚函数表的指针存在于对象实例的最前面的位置（这是为了保证尽可能高性能的获取虚函数表的地址----如果有多层继承或是多重继承的情况下，这些情况下，每次只需要访问对象的前几个字节就可以得到虚函数表所在地址，提高了访问呢效率）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中的函数指针，并且调用相应的函数。

单继承情况下，派生类继承基类，如果基类中有虚函数并且没有重载基类中的虚函数，那么在派生类的虚函数表中，基类的虚函数放在前面（将基类的虚函数表中的内容复制过来），派生类自己的虚函数跟在后面，并且以一个特定的符号结尾表示虚函数表的内容结束了。如果派生类中重写了基类中的虚函数，那么在派生类的虚函数表中，原本存放的基类该虚函数的地址会被派生类中重写的那个函数地址给覆盖掉，基类中其它的没有被重写的虚函数的地址保持不变。

多重继承的情况下，如果派生类没有重载基类的虚函数，那么派生类对象中会保留所有基类的虚函数表的地址，也就是说如果基类有3个，那么派生类对象的前3个地址空间分别存放了这三个基类的虚函数表的地址。每个父类都有自己的虚函数表，子类的虚函数地址放在了所继承的第一个基类的虚函数表的最后面（所谓的第一个基类是按照声明顺序来判断的）。这样做的目的是为了解决不同的基类类的指针指向同一个子类实例，而能够调用到实际的函数。

此外，在多重继承的情况下，如果派生类重载了基类的虚函数，跟上面那点的主要区别是，所有被重载的基类虚函数表中的虚函数地址会被派生类中新的重载函数的地址给替换掉。这样，我们就可以在任意静态类型的父类来指向子类，并且调用子类的重载函数。

> 通过基类指针来调用派生类中未重载的函数会被编译器视为非法，但是在运行过程中可以通过指针的方式来访问虚函数表进行访问。

> 如果基类的虚函数是`private`或者`protected`的，但这些非`public`的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些非`public`的函数，这对于程序的安全性有一定的威胁。


> 需要代码验证，如果对基类虚函数进行了重载，那么使用基类指针指向那个被重载的函数是基类的还是派生类的。基类指针使用派生类进行new操作是否可行，派生类指针使用基类进行new是否可行，如果可行，发生重载之后调用的是哪个类的方法。


 C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。


首先，**每个使用虚函数的类（或者从使用虚函数的类派生出来的类）都有自己的虚拟表**。该表只是编译器在编译的